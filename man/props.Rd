% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{props}
\alias{props}
\alias{props.ranking}
\alias{props.vsel}
\title{Ranking proportions from fold-wise predictor rankings}
\usage{
props(object, ...)

\method{props}{ranking}(object, cumulate = FALSE, nterms_max = ncol(object[["foldwise"]]), ...)

\method{props}{vsel}(object, ...)
}
\arguments{
\item{object}{For \code{\link[=props.ranking]{props.ranking()}}: an object of class \code{ranking} (returned
by \code{\link[=ranking]{ranking()}}). For \code{\link[=props.vsel]{props.vsel()}}: an object of class \code{vsel} (returned by
\code{\link[=varsel]{varsel()}} or \code{\link[=cv_varsel]{cv_varsel()}}) that \code{\link[=ranking]{ranking()}} will be applied to internally
before then calling \code{\link[=props.ranking]{props.ranking()}}.}

\item{...}{For \code{\link[=props.vsel]{props.vsel()}}: arguments passed to \code{\link[=props.ranking]{props.ranking()}}. For
\code{\link[=props.ranking]{props.ranking()}}: currently ignored.}

\item{cumulate}{A single logical value indicating whether the ranking
proportions should be cumulated across increasing submodel sizes (\code{TRUE})
or not (\code{FALSE}).}

\item{nterms_max}{A single numeric value giving the maximum submodel size
(number of predictor terms) to include in the returned matrix. Note that
\code{nterms_max} does not count the intercept, so \code{nterms_max = 1} corresponds
to the submodel consisting of the first (non-intercept) predictor term.}
}
\value{
If the \code{ranking} object contains only a full-data predictor ranking
(i.e., if it is based on a \code{vsel} object created by \code{\link[=varsel]{varsel()}} or by
\code{\link[=cv_varsel]{cv_varsel()}}, but the latter with \code{validate_search = FALSE}), then \code{NULL}
is returned. If the \code{ranking} object includes fold-wise predictor rankings
(i.e., if it is based on a \code{vsel} object created by \code{\link[=cv_varsel]{cv_varsel()}} with
\code{validate_search = TRUE}), then a numeric matrix with \code{nterms_max} rows and
\code{nterms_max} columns is returned, containing the ranking proportions based
on these fold-wise predictor rankings (with the rows corresponding to the
submodel sizes and the columns to the predictor terms, sorted according to
the full-data predictor ranking). If \code{cumulate} is \code{FALSE}, then the
returned matrix is of class \code{propsrk}. If \code{cumulate} is \code{TRUE}, then the
returned matrix is of classes \code{cumulpropsrk} and \code{propsrk} (in this order).

Note that if \code{cumulate} is \code{FALSE}, then the values in the returned matrix
only need to sum to 1 (column-wise and row-wise) if \code{nterms_max} is equal
to the full model size. Likewise, if \code{cumulate} is \code{TRUE}, then the value
\code{1} only needs to occur in each column of the returned matrix if
\code{nterms_max} is equal to the full model size.
}
\description{
Calculates the \emph{ranking proportions} from the fold-wise predictor rankings in
a cross-validation (CV) with fold-wise searches. For a given predictor \code{x}
and a given submodel size \code{j}, the ranking proportion is the proportion of CV
folds which have predictor \code{x} at position \code{j} of their predictor ranking.
While these ranking proportions are helpful for investigating variability in
the predictor ranking, they can also be \emph{cumulated} across submodel sizes.
The cumulated ranking proportions are more helpful when it comes to model
selection.
}
\examples{
# TODO

}
\seealso{
\code{\link[=plot.propsrk]{plot.propsrk()}}
}
